import pandas as pd
from Bio import SeqIO
from Bio.Seq import Seq
from collections import defaultdict
import random
import subprocess

#请先用以下
"""
awk '$0 ~ /transcript_type "protein_coding"/ || $0 ~ /gene_type "protein_coding"/' gencode.vXX.annotation.gtf > coding_only.gtf
"""

##维护日志1 2025/6/17/21/37 所有的start;end都是左闭右开区间
# ----- 验证方式1 固定数据集与验证集 ----- #

def __extract_splice_sites__(gtf_path, fasta_path, flank=50, neg_pos_per_transcript=2):
    """
    Extract splice sites from a GTF file and generate negative samples.
    Negative samples are generated by selecting middlepoints between adjacent splice sites
    Args:
        gtf_path (str): Path to the GTF file.
        fasta_path (str): Path to the FASTA file.   
        flank (int): Flanking region size around splice sites.
        neg_pos_per_transcript (int): Number of negative samples to generate per transcript.
    Returns:
        list: A list of dictionaries containing sequences and their labels.
    """
    # Read genome sequence
    genome = SeqIO.to_dict(SeqIO.parse(fasta_path, "fasta"))
    transcripts = defaultdict(list)
    splice_coords_set = set()  # Store all positive sample coordinates to avoid overlap with negative samples
    
    # Step 1: Read GTF and aggregate exons by transcript
    with open(gtf_path, 'r') as gtf:
        for line in gtf:
            if line.startswith('#'):
                continue
            fields = line.strip().split('\t')
            if fields[2] != 'exon':
                continue
            chrom = fields[0]
            start = int(fields[3]) - 1
            end = int(fields[4])
            strand = fields[6]
            info = fields[8]
            tid = [x for x in info.split(';') if 'transcript_id' in x][0].split('"')[1]
            transcripts[tid].append((start, end, chrom, strand))
    
    samples = []
    
    for tid,exons in transcripts.items():
        if len(exons) < 2:
            continue # No splice sites if fewer than 2 exons
        strand = exons[0][3]   
        chrom = exons[0][2]
        chrom_seq = genome[chrom].seq
        # Sampling positive splice sites
        
        exons_sorted = sorted(exons, key=lambda x: x[0]) if strand == '+' else sorted(exons, key=lambda x:-x[1])  # Sort by position
        # 为什么要排序？ # 因为我们需要确保正负链的剪接位点是正确的顺序，正链从小到大，负链从大到小
        for i in range(len(exons_sorted) - 1):
            exon1, exon2 = exons_sorted[i], exons_sorted[i + 1]

            # ----- Donor site -----
            donor_pos = exon1[1] if strand == '+' else exon1[0] - 1  # 3'端：正链取末尾，负链取起始 -1
            if donor_pos - flank >= 0 and donor_pos + flank < len(chrom_seq):
                donor_seq = chrom_seq[donor_pos - flank: donor_pos + flank + 1] # 左闭右开
                if strand == '-':
                    donor_seq = donor_seq.reverse_complement()
                samples.append({
                    'seq': str(donor_seq),
                    'label': 'donor',
                })
                splice_coords_set.add((chrom, donor_pos, strand))

            # ----- Acceptor site -----
            acceptor_pos = exon2[0] - 1 if strand == '+' else exon2[1]  # 3'端：正链取起始-1，负链取末尾
            if acceptor_pos - flank >= 0 and acceptor_pos + flank < len(chrom_seq):
                acceptor_seq = chrom_seq[acceptor_pos - flank: acceptor_pos + flank+ 1] # 左闭右开
                if strand == '-':
                    acceptor_seq = acceptor_seq.reverse_complement()
                samples.append({
                    'seq': str(acceptor_seq),
                    'label': 'acceptor',
                })
                splice_coords_set.add((chrom, acceptor_pos, strand))

        # Sampling negative samples
        for _ in range(neg_pos_per_transcript):
            for _try in range(10):
                # Try to find a negative sample
                neg_pos = random.randint(0, len(chrom_seq) - 1)
                if (chrom, neg_pos, strand) in splice_coords_set:
                    continue
                if neg_pos - flank < 0 or neg_pos + flank >= len(chrom_seq):
                    continue
                neg_seq = chrom_seq[neg_pos - flank: neg_pos + flank+ 1] # 左闭右开
                if strand == '-':
                    neg_seq = neg_seq.reverse_complement()
                samples.append({'seq': str(neg_seq), 'label': 'negative',  'pos': -1,'strand':strand})
                break
    return samples

def __stocastic_sampling__(samples,num_samples=10000):
    """
    Perform stochastic sampling on the given samples. We need to sample 10000 donor 10000 acceptor and 10000 negative samples.`
    Args:
        samples (list): List of samples to be sampled.
    Returns:
        list: A list of sampled sequences.
    """
    samples_donor = [s for s in samples if s['label'] == 'donor']
    samples_acceptor = [s for s in samples if s['label'] == 'acceptor']
    samples_negative = [s for s in samples if s['label'] == 'negative']
    if len(samples_donor) < num_samples or len(samples_acceptor) < num_samples or len(samples_negative) < num_samples:
        raise ValueError("Not enough samples to sample from.")
    # Randomly sample from each category
    sampled_donor = random.sample(samples_donor, num_samples)
    sampled_acceptor = random.sample(samples_acceptor, num_samples) 
    sampled_negative = random.sample(samples_negative, num_samples)
    # Combine the sampled sequences
    sampled = []
    sampled.extend(sampled_donor)
    sampled.extend(sampled_acceptor)
    sampled.extend(sampled_negative)
    return sampled
def generally_create_train_dataset(gtf_path, fasta_path,num_samples=10000, flank=50, neg_pos_per_transcript=2):
    """
    Create a dataset from the given GTF and FASTA files."""
    samples = __extract_splice_sites__(gtf_path, fasta_path, flank, neg_pos_per_transcript)
    sampled = __stocastic_sampling__(samples, num_samples)
    return sampled

# ----- 验证方式2 随机采样数据集与验证集 ----- #
#print(generally_create_train_dataset('../test2.gtf', './GRCh38.primary_assembly.genome.fa', num_samples=1))
def create_validation_dataset(gtf_path, fasta_path, flank=50,num_samples=10000):
    """
    Create a validation dataset from the given GTF and FASTA files.Our validation
    set consists of a very long range of sequences, and we will specify all the
    splice sites among them
    Args:
        gtf_path (str): Path to the GTF file.
        fasta_path (str): Path to the FASTA file.
        flank (int): Flanking region size around splice sites.
    Returns:
        list: A list of dictionaries containing sequences and their labels.
    """
    # 获取基因组和注释
    genome = SeqIO.to_dict(SeqIO.parse(fasta_path, "fasta"))
    transcripts = defaultdict(list)
    # 设置坐标集合
    splice_coords_set_donor = set()  # Store all positive sample coordinates to avoid overlap with negative samples
    splice_coords_set_acceptor = set()
    # 获取染色体名称
    chrom_name_set = set()

    with open(fasta_path) as handle:
        for record in SeqIO.parse(handle, "fasta"):
            chrom_name_set.add(record.id)

    chrom_names = list(chrom_name_set)
    # Step 1: Read GTF and aggregate exons by transcript
    with open(gtf_path, 'r') as gtf:
        for line in gtf:
            if line.startswith('#'):
                continue
            fields = line.strip().split('\t')
            if fields[2] != 'exon':
                continue
            chrom = fields[0]
            start = int(fields[3]) - 1
            end = int(fields[4])
            strand = fields[6]
            info = fields[8]
            tid = [x for x in info.split(';') if 'transcript_id' in x][0].split('"')[1] #tid为基因的染色体定位
            transcripts[tid].append((start, end, chrom, strand))
    samples = []
    for tid,exons in transcripts.items():
        if len(exons) < 2:
            continue # No splice sites if fewer than 2 exons
        strand = exons[0][3]   
        chrom = exons[0][2]
        chrom_seq = genome[chrom].seq
        # Sampling positive splice sites
        
        exons_sorted = sorted(exons, key=lambda x: x[0]) if strand == '+' else sorted(exons, key=lambda x: -x[1])  # Sort by position
        # 为什么要排序？ # 因为我们需要确保正负链的剪接位点是正确的顺序，正链从小到大，负链从大到小
        for i in range(len(exons_sorted) - 1):
            exon1, exon2 = exons_sorted[i], exons_sorted[i + 1]

            # ----- Donor site -----
            donor_pos = exon1[1] if strand == '+' else exon1[0] - 1  # 3'端：正链取末尾，负链取起始 -1
            if donor_pos - flank >= 0 and donor_pos + flank < len(chrom_seq):
                splice_coords_set_donor.add((chrom, donor_pos, strand))

            # ----- Acceptor site -----
            acceptor_pos = exon2[0] - 1 if strand == '+' else exon2[1]  # 3'端：正链取起始-1，负链取末尾
            if acceptor_pos - flank >= 0 and acceptor_pos + flank < len(chrom_seq):
                splice_coords_set_acceptor.add((chrom, acceptor_pos, strand))
        # Build donor / acceptor sample list
    def extract_seq(chrom, pos, strand):
        seq = genome[chrom].seq[pos - flank: pos + flank + 1]
        return seq.reverse_complement() if strand == '-' else seq

    samples = []

    # Shuffle and sample splice coords
    donor_list = list(splice_coords_set_donor)
    acceptor_list = list(splice_coords_set_acceptor)
    random.shuffle(donor_list)
    random.shuffle(acceptor_list)

    num_per_class = num_samples // 3
    donor_list = donor_list[:num_per_class]
    acceptor_list = acceptor_list[:num_per_class]

    for chrom, pos, strand in donor_list:
        samples.append({
            'seq': str(extract_seq(chrom, pos, strand)),
            'label': 'donor'
        })
    for chrom, pos, strand in acceptor_list:
        samples.append({
            'seq': str(extract_seq(chrom, pos, strand)),
            'label': 'acceptor'
        })

    # Sample negatives
    negative_coords = set()
    total_negatives = 0
    attempts = 0
    chrom_names = list(genome.keys())

    while total_negatives < num_per_class and attempts < num_per_class * 20:
        chrom = random.choice(chrom_names)
        strand = '+' if random.random() > 0.5 else '-'
        chrom_seq = genome[chrom].seq
        pos = random.randint(flank, len(chrom_seq) - flank - 1)
        if (chrom, pos, strand) in splice_coords_set_donor or (chrom, pos, strand) in splice_coords_set_acceptor:
            attempts += 1
            continue
        if (chrom, pos, strand) in negative_coords:
            attempts += 1
            continue
        neg_seq = extract_seq(chrom, pos, strand)
        if len(neg_seq) != 2 * flank + 1:
            attempts += 1
            continue
        samples.append({
            'seq': str(neg_seq),
            'label': 'negative'
        })
        negative_coords.add((chrom, pos, strand))
        total_negatives += 1

    print(f"Sample counts — Donor: {len(donor_list)}, Acceptor: {len(acceptor_list)}, Negative: {total_negatives}")
    return samples
# ----- 验证方式3 随机长序列的连续验证（模拟诸位点扫描） ----- #
def load_sampling_object(gtf_path, fasta_path, flank=50):
    genome = SeqIO.to_dict(SeqIO.parse(fasta_path, "fasta"))
    transcripts = defaultdict(list)
    # 设置坐标集合
    splice_coords_set_donor = set()  # Store all positive sample coordinates to avoid overlap with negative samples
    splice_coords_set_acceptor = set()
    # Step 1: Read GTF and aggregate exons by transcript
    with open(gtf_path, 'r') as gtf:
        for line in gtf:
            if line.startswith('#'):
                continue
            fields = line.strip().split('\t')
            if fields[2] != 'exon':
                continue
            chrom = fields[0]
            start = int(fields[3]) - 1
            end = int(fields[4])
            strand = fields[6]
            info = fields[8]
            tid = [x for x in info.split(';') if 'transcript_id' in x][0].split('"')[1] #tid为基因的染色体定位
            transcripts[tid].append((start, end, chrom, strand))
    for tid,exons in transcripts.items():
        if len(exons) < 2:
            continue # No splice sites if fewer than 2 exons
        strand = exons[0][3]   
        chrom = exons[0][2]
        chrom_seq = genome[chrom].seq
        # Sampling positive splice sites
        
        exons_sorted = sorted(exons, key=lambda x: x[0]) if strand == '+' else sorted(exons, key=lambda x: -x[1])  # Sort by position
        # 为什么要排序？ # 因为我们需要确保正负链的剪接位点是正确的顺序，正链从小到大，负链从大到小
        for i in range(len(exons_sorted) - 1):
            exon1, exon2 = exons_sorted[i], exons_sorted[i + 1]

            # ----- Donor site -----
            donor_pos = exon1[1] if strand == '+' else exon1[0] - 1  # 3'端：正链取末尾，负链取起始 -1
            if donor_pos - flank >= 0 and donor_pos + flank < len(chrom_seq):
                splice_coords_set_donor.add((chrom, donor_pos, strand))

            # ----- Acceptor site -----
            acceptor_pos = exon2[0] - 1 if strand == '+' else exon2[1]  # 3'端：正链取起始-1，负链取末尾
            if acceptor_pos - flank >= 0 and acceptor_pos + flank < len(chrom_seq):
                splice_coords_set_acceptor.add((chrom, acceptor_pos, strand))
    return genome,splice_coords_set_donor,splice_coords_set_acceptor


# ----- 功能检查 -----
def check_splice_site_motifs(samples):
    """
    检查剪接位点处的碱基（GT/AG等）是否正确，考虑正负链方向。
    """
    from collections import Counter
    motif_counter = Counter()

    for sample in samples:
        if sample['label'] in {'donor', 'acceptor'}:
            seq = sample['seq'].upper()
            pos = sample['pos']
            if pos < 1 or pos + 1 >= len(seq):
                continue

            # 注意：我们无法直接知道正负链，因为在extract中没有存strand
            # 这里建议在extract中样本加一个字段：'strand': strand
            strand = sample.get('strand')  # 默认正链（原先代码没有写入）

            if sample['label'] == 'donor':
                #if strand == '+':
                motif = seq[pos:pos+2]  # donor: GT
                #else:
                #    motif = str(Seq(seq[pos-1:pos+1]).reverse_complement())  # donor on -: reverse of AC = GT
            else:  # acceptor
                #if strand == '+':
                motif = seq[pos-1:pos+1]  # AG


            motif_counter[(sample['label'], motif)] += 1

    print("剪接位点处的碱基统计（考虑正负链）:")
    for key, count in motif_counter.items():
        print(f"{key[0]:<8} | {key[1]}: {count}")
if __name__=="__main__":
    samples = __extract_splice_sites__(gtf_path='./coding_only.gtf', fasta_path='./GRCh38.primary_assembly.genome.fa', flank=50)
    check_splice_site_motifs(samples)